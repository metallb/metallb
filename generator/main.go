// SPDX-License-Identifier:Apache-2.0

package main

import (
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"time"

	"go.universe.tf/metallb/api/v1beta1"
	"go.universe.tf/metallb/api/v1beta2"
	"go.universe.tf/metallb/internal/config"
	"go.universe.tf/metallb/internal/pointer"
	"go.universe.tf/metallb/internal/version"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"sigs.k8s.io/yaml"
)

const (
	separator      = "---\n"
	autoGenComment = "# This was autogenerated by MetalLB's custom resource generator.\n"
	outPutFileName = "resources.yaml"
)

var (
	resourcesNameSpace = "metallb-system"
	inputDirPath       = "/var/input"
)

func main() {
	source := flag.String("source", "./config.yaml", "name of the configmap file to convert")
	flag.Parse()
	log.Printf("MetalLB generator starting. commit: %s branch: %s goversion: %s",
		version.CommitHash(), version.Branch(), version.GoString())

	f, err := os.Create(filepath.Join(inputDirPath, outPutFileName))
	if err != nil {
		log.Fatalf("failed to create output file: %s", err)
	}
	defer f.Close()

	err = generate(f, *source)
	if err != nil {
		log.Fatalf("failed to generate resources: %s", err)
	}
	log.Println("Generator finished successfully!")
}

// generate gets a name of a metallb configmap file, converts it to
// the matching metallb custom resources yamls, and returns it as a string.
func generate(w io.Writer, origin string) error {
	log.Println("Reading configmap")
	raw, err := readConfig(origin)
	if err != nil {
		return err
	}

	log.Println("Decoding configmap")
	cf, err := decodeConfigFile(raw)
	if err != nil {
		return err
	}

	log.Println("Creating custom resources")
	resources, err := resourcesFor(cf)
	if err != nil {
		return err
	}

	log.Println("Validating the custom resources")
	_, err = config.For(resources, config.DontValidate)
	if err != nil {
		return err
	}

	log.Println("Creating the output YAML")
	output, err := createResourcesYAMLs(resources)
	if err != nil {
		return err
	}

	log.Println("Writing the output")
	_, err = fmt.Fprint(w, output)
	if err != nil {
		return err
	}

	return nil
}

func readConfig(origin string) ([]byte, error) {
	fp := filepath.Join(inputDirPath, origin)
	f, err := os.Open(fp)
	if err != nil {
		return nil, fmt.Errorf("failed to open file %s: %v\n", fp, err)
	}
	defer f.Close()

	raw, err := ioutil.ReadAll(f)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %v\n", origin, err)
	}

	return raw, nil
}

// decodeConfigFile gets metallb configmap raw bytes and decodes it into
// a configFile object.
func decodeConfigFile(raw []byte) (*configFile, error) {
	scheme, err := initSchema()
	if err != nil {
		return nil, err
	}

	factory := serializer.NewCodecFactory(scheme)
	decoder := factory.UniversalDeserializer()
	obj, _, err := decoder.Decode(raw, nil, nil)
	if err != nil {
		return nil, err
	}

	config, ok := obj.(*corev1.ConfigMap)
	if !ok {
		return nil, fmt.Errorf("not a configmap.")
	}

	// set the namespace for the resources
	if config.Namespace != "" {
		resourcesNameSpace = config.Namespace
	}

	cf := &configFile{}
	err = yaml.Unmarshal([]byte(config.Data["config"]), cf)
	if err != nil {
		return nil, err
	}

	return cf, nil
}

func resourcesFor(cf *configFile) (config.ClusterResources, error) {
	var r config.ClusterResources
	var err error

	r.BFDProfiles = bfdProfileFor(cf)
	r.Communities = communitiesFor(cf)
	r.Peers, err = peersFor(cf)
	if err != nil {
		return config.ClusterResources{}, err
	}

	r.Pools = ipAddressPoolsFor(cf)
	r.BGPAdvs = bgpAdvertisementsFor(cf)
	r.L2Advs = l2AdvertisementsFor(cf)

	return r, nil
}

func bfdProfileFor(c *configFile) []v1beta1.BFDProfile {
	ret := make([]v1beta1.BFDProfile, len(c.BFDProfiles))

	for i, bfd := range c.BFDProfiles {
		b := v1beta1.BFDProfile{
			ObjectMeta: metav1.ObjectMeta{
				Name:      bfd.Name,
				Namespace: resourcesNameSpace,
			},
			Spec: v1beta1.BFDProfileSpec{
				ReceiveInterval:  bfd.ReceiveInterval,
				TransmitInterval: bfd.TransmitInterval,
				DetectMultiplier: bfd.DetectMultiplier,
				EchoInterval:     bfd.EchoInterval,
				EchoMode:         &bfd.EchoMode,
				PassiveMode:      &bfd.PassiveMode,
				MinimumTTL:       bfd.MinimumTTL,
			},
		}
		ret[i] = b
	}
	return ret
}

// communitiesFor aggregates all the community aliases into one community resource.
func communitiesFor(cf *configFile) []v1beta1.Community {
	if len(cf.BGPCommunities) == 0 {
		return nil
	}

	var communitiesAliases []v1beta1.CommunityAlias

	for n, v := range cf.BGPCommunities {
		communityAlias := v1beta1.CommunityAlias{
			Name:  n,
			Value: v,
		}
		communitiesAliases = append(communitiesAliases, communityAlias)
	}

	ret := v1beta1.Community{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "communities",
			Namespace: resourcesNameSpace,
		},
		Spec: v1beta1.CommunitySpec{
			Communities: communitiesAliases,
		},
	}
	return []v1beta1.Community{ret}
}

func peersFor(c *configFile) ([]v1beta2.BGPPeer, error) {
	var ret []v1beta2.BGPPeer
	for i, peer := range c.Peers {
		p, err := parsePeer(peer)
		if err != nil {
			return nil, err
		}
		p.Name = fmt.Sprintf("peer%d", i+1)
		p.Namespace = resourcesNameSpace
		ret = append(ret, *p)
	}
	return ret, nil
}

func parsePeer(p peer) (*v1beta2.BGPPeer, error) {
	holdTime, err := parseHoldTime(p.HoldTime)
	if err != nil {
		return nil, err
	}
	keepaliveTime, err := parseKeepaliveTime(holdTime, p.KeepaliveTime)
	if err != nil {
		return nil, err
	}

	nodeSels := make([]metav1.LabelSelector, 0)
	for _, sel := range p.NodeSelectors {
		s := parseNodeSelector(sel)
		nodeSels = append(nodeSels, *s)
	}

	return &v1beta2.BGPPeer{
		ObjectMeta: metav1.ObjectMeta{
			Namespace: resourcesNameSpace,
		},
		Spec: v1beta2.BGPPeerSpec{
			MyASN:         p.MyASN,
			ASN:           p.ASN,
			Address:       p.Addr,
			SrcAddress:    p.SrcAddr,
			Port:          p.Port,
			HoldTime:      metav1.Duration{Duration: holdTime},
			KeepaliveTime: metav1.Duration{Duration: keepaliveTime},
			RouterID:      p.RouterID,
			NodeSelectors: nodeSels,
			Password:      p.Password,
			BFDProfile:    p.BFDProfile,
			EBGPMultiHop:  p.EBGPMultiHop,
		},
	}, nil
}

func parseNodeSelector(sel nodeSelector) *metav1.LabelSelector {
	ret := &metav1.LabelSelector{}

	ret.MatchLabels = sel.MatchLabels
	ret.MatchExpressions = []metav1.LabelSelectorRequirement{}

	for _, m := range sel.MatchExpressions {

		matchExp := &metav1.LabelSelectorRequirement{
			Key:      m.Key,
			Operator: metav1.LabelSelectorOperator(m.Operator),
			Values:   m.Values,
		}
		matchExp.Values = make([]string, len(m.Values))
		copy(matchExp.Values, m.Values)
		ret.MatchExpressions = append(ret.MatchExpressions, *matchExp)
	}
	return ret
}

func parseHoldTime(ht string) (time.Duration, error) {
	if ht == "" {
		return 90 * time.Second, nil
	}
	d, err := time.ParseDuration(ht)
	if err != nil {
		return 0, fmt.Errorf("invalid hold time %q: %s", ht, err)
	}
	rounded := time.Duration(int(d.Seconds())) * time.Second
	if rounded != 0 && rounded < 3*time.Second {
		return 0, fmt.Errorf("invalid hold time %q: must be 0 or >=3s", ht)
	}
	return rounded, nil
}

func parseKeepaliveTime(ht time.Duration, ka string) (time.Duration, error) {
	// If keepalive time not set lets use 1/3 of holdtime.
	if ka == "" {
		return ht / 3, nil
	}
	d, err := time.ParseDuration(ka)
	if err != nil {
		return 0, fmt.Errorf("invalid keepalive time %q: %s", ka, err)
	}
	rounded := time.Duration(int(d.Seconds())) * time.Second
	return rounded, nil
}

func ipAddressPoolsFor(c *configFile) []v1beta1.IPAddressPool {
	ret := make([]v1beta1.IPAddressPool, len(c.Pools))
	for i, addresspool := range c.Pools {
		var ap v1beta1.IPAddressPool
		ap.Name = addresspool.Name
		ap.Namespace = resourcesNameSpace
		ap.Spec.Addresses = make([]string, len(addresspool.Addresses))
		copy(ap.Spec.Addresses, addresspool.Addresses)
		if addresspool.AutoAssign != nil {
			ap.Spec.AutoAssign = pointer.BoolPtr(*addresspool.AutoAssign)
		}
		ret[i] = ap
	}
	return ret
}

func bgpAdvertisementsFor(c *configFile) []v1beta1.BGPAdvertisement {
	ret := make([]v1beta1.BGPAdvertisement, 0)
	index := 1
	for _, ap := range c.Pools {
		for _, bgpAdv := range ap.BGPAdvertisements {
			var b v1beta1.BGPAdvertisement
			b.Name = fmt.Sprintf("bgpadvertisement%d", index)
			index = index + 1
			b.Namespace = resourcesNameSpace
			b.Spec.Communities = make([]string, len(bgpAdv.Communities))
			copy(b.Spec.Communities, bgpAdv.Communities)
			if bgpAdv.AggregationLength != nil {
				b.Spec.AggregationLength = pointer.Int32Ptr(*bgpAdv.AggregationLength)
			}
			if bgpAdv.AggregationLengthV6 != nil {
				b.Spec.AggregationLengthV6 = pointer.Int32Ptr(*bgpAdv.AggregationLengthV6)
			}
			b.Spec.LocalPref = bgpAdv.LocalPref
			b.Spec.IPAddressPools = []string{ap.Name}
			ret = append(ret, b)
		}
		if len(ap.BGPAdvertisements) == 0 && ap.Protocol == BGP {
			ret = append(ret, emptyBGPAdv(ap.Name, index))
			index = index + 1
		}
	}
	return ret
}

func emptyBGPAdv(addressPoolName string, index int) v1beta1.BGPAdvertisement {
	return v1beta1.BGPAdvertisement{
		ObjectMeta: metav1.ObjectMeta{
			Name:      fmt.Sprintf("bgpadvertisement%d", index),
			Namespace: resourcesNameSpace,
		},
		Spec: v1beta1.BGPAdvertisementSpec{
			IPAddressPools: []string{addressPoolName},
		},
	}
}

func l2AdvertisementsFor(c *configFile) []v1beta1.L2Advertisement {
	ret := make([]v1beta1.L2Advertisement, 0)
	index := 1
	for _, addresspool := range c.Pools {
		if addresspool.Protocol == Layer2 {
			l2Adv := v1beta1.L2Advertisement{
				ObjectMeta: metav1.ObjectMeta{
					Name:      fmt.Sprintf("l2advertisement%d", index),
					Namespace: resourcesNameSpace,
				},
				Spec: v1beta1.L2AdvertisementSpec{
					IPAddressPools: []string{addresspool.Name},
				},
			}
			index = index + 1
			ret = append(ret, l2Adv)
		}
	}
	return ret
}

func createResourcesYAMLs(resources config.ClusterResources) (string, error) {
	s, err := initSchema()
	if err != nil {
		return "", err
	}
	bfdProfiles, err := serializeObjects(bfdProfilesToObjects(resources.BFDProfiles), *s)
	if err != nil {
		return "", err
	}
	communities, err := serializeObjects(communitiesToObjects(resources.Communities), *s)
	if err != nil {
		return "", err
	}
	peers, err := serializeObjects(peersToObjects(resources.Peers), *s)
	if err != nil {
		return "", err
	}
	ipaddresspools, err := serializeObjects(ipaddresspoolsToObjects(resources.Pools), *s)
	if err != nil {
		return "", err
	}
	bgpadvertisements, err := serializeObjects(bgpAdvertisementsToObjects(resources.BGPAdvs), *s)
	if err != nil {
		return "", err
	}
	l2advertisements, err := serializeObjects(l2AdvertisementsToObjects(resources.L2Advs), *s)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("%s%s%s%s%s%s%s",
		autoGenComment, bfdProfiles, peers, communities, ipaddresspools, bgpadvertisements, l2advertisements), nil
}

func initSchema() (*runtime.Scheme, error) {
	s := runtime.NewScheme()
	err := v1beta1.AddToScheme(s)
	if err != nil {
		return nil, err
	}
	err = v1beta2.AddToScheme(s)
	if err != nil {
		return nil, err
	}
	err = corev1.AddToScheme(s)
	if err != nil {
		return nil, err
	}
	return s, nil
}

func serializeObjects(objects []runtime.Object, s runtime.Scheme) (string, error) {
	if len(objects) == 0 {
		return "", nil
	}
	gvks, _, err := s.ObjectKinds(objects[0])
	if err != nil {
		return "", err
	}

	version := gvks[0].Version
	group := gvks[0].Group
	kind := gvks[0].Kind
	ret := ""

	for _, o := range objects {
		ret += fmt.Sprintf("apiVersion: %s/%s\n", group, version)
		ret += fmt.Sprintf("kind: %s\n", kind)
		bs, err := yaml.Marshal(o)
		if err != nil {
			return "", err
		}
		ret += string(bs) + separator
	}
	return ret, nil
}

func bfdProfilesToObjects(profiles []v1beta1.BFDProfile) []runtime.Object {
	ret := make([]runtime.Object, 0)
	for _, p := range profiles {
		ret = append(ret, p.DeepCopyObject())
	}
	return ret
}

func peersToObjects(peers []v1beta2.BGPPeer) []runtime.Object {
	ret := make([]runtime.Object, 0)
	for _, p := range peers {
		ret = append(ret, p.DeepCopyObject())
	}
	return ret
}

func communitiesToObjects(communities []v1beta1.Community) []runtime.Object {
	ret := make([]runtime.Object, 0)
	for _, c := range communities {
		ret = append(ret, c.DeepCopyObject())
	}
	return ret
}

func ipaddresspoolsToObjects(pools []v1beta1.IPAddressPool) []runtime.Object {
	ret := make([]runtime.Object, 0)
	for _, p := range pools {
		ret = append(ret, p.DeepCopyObject())
	}
	return ret
}

func bgpAdvertisementsToObjects(bgpAdvs []v1beta1.BGPAdvertisement) []runtime.Object {
	ret := make([]runtime.Object, 0)
	for _, c := range bgpAdvs {
		ret = append(ret, c.DeepCopyObject())
	}
	return ret
}

func l2AdvertisementsToObjects(l2Advs []v1beta1.L2Advertisement) []runtime.Object {
	ret := make([]runtime.Object, 0)
	for _, adv := range l2Advs {
		ret = append(ret, adv.DeepCopyObject())
	}
	return ret
}
